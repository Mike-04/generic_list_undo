        -:    0:Source:/mnt/c/Users/White Fox/Downloads/l4/l4/repository.c
        -:    0:Graph:/mnt/c/Users/White Fox/Downloads/l4/l4/cmake-build-debug-coverage/CMakeFiles/l4.dir/repository.c.gcno
        -:    0:Data:/mnt/c/Users/White Fox/Downloads/l4/l4/cmake-build-debug-coverage/CMakeFiles/l4.dir/repository.c.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2:
        -:    3:Solution written by
        -:    4:Ilovan Cristian Daniel
        -:    5:
        -:    6:*/
        -:    7:
        -:    8:#include "repository.h"
        -:    9:
        -:   10:// constructs products object
        -:   11:// in:
        -:   12:// p is a product object
        -:   13:// out:
        -:   14:// p is a constructed product object
function productsConstructor called 16 returned 100% blocks executed 100%
       16:   15:void productsConstructor(Products *p)
        -:   16:{
       16:   17:	p->products = NULL;
       16:   18:	p->size = 0;
       16:   19:}
        -:   20:
        -:   21:// destructs
function productsDestructor called 15 returned 100% blocks executed 100%
       15:   22:void productsDestructor(Products *p)
        -:   23:{
       15:   24:	if (p->products != NULL)
       15:   24-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 1
       14:   25:		free(p->products);
       14:   25-block  0
       15:   26:}
        -:   27:
        -:   28:// see if there exists an product with
        -:   29:// useful attributes
        -:   30:// in:
        -:   31:// p = repository where to search
        -:   32:// t = product to search
        -:   33:// out:
        -:   34:// returns position if found or false if not
function repositoryExistsAttributes called 13 returned 100% blocks executed 100%
       13:   35:int repositoryExistsAttributes(Products *p, Product* t)
        -:   36:{
       13:   37:	unsigned int size = p->size;
        -:   38:	
       18:   39:	for (unsigned int i = 0; i < size; ++i)
       13:   39-block  0
        5:   39-block  1
       18:   39-block  2
branch  0 taken 9
branch  1 taken 9 (fallthrough)
        9:   40:		if (productEqualAttributes(&p->products[i], t))
        9:   40-block  0
call    0 returned 9
branch  1 taken 4 (fallthrough)
branch  2 taken 5
        4:   41:			return i;
        4:   41-block  0
        -:   42:		
        9:   43:	return -1;
        9:   43-block  0
        -:   44:}
        -:   45:
        -:   46:// see if there is a product with
        -:   47:// search identification
        -:   48:// in:
        -:   49:// p = repository where to search
        -:   50:// identification = identification to search
        -:   51:// out:
        -:   52:// returns position if found or false if not
function repositoryExists called 17 returned 100% blocks executed 100%
       17:   53:bool repositoryExists(Products *p, unsigned int identification)
        -:   54:{
       17:   55:	if (identification >= p->size)
       17:   55-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 12
        5:   56:		return 0;
        5:   56-block  0
       12:   57:	return p->products[identification].memory;
       12:   57-block  0
        -:   58:}
        -:   59:
        -:   60:// adds a product to repository
        -:   61:// in:
        -:   62:// p = repository to where to add
        -:   63:// t = product to add
        -:   64:// out:
        -:   65:// the product t was added to repository p
function repositoryAdauga called 19 returned 100% blocks executed 100%
       19:   66:unsigned int repositoryAdauga(Products* p, Product* t)
        -:   67:{
       19:   68:	unsigned int n = p->size;
       19:   69:	++(p->size);
       19:   70:	Product *pointer = (Product*)malloc((n + 1) * sizeof(Product));
       27:   71:	for (unsigned int i = 0; i < n; ++i)
       19:   71-block  0
       27:   71-block  1
branch  0 taken 8
branch  1 taken 19 (fallthrough)
        8:   72:		pointer[i] = p->products[i];
        8:   72-block  0
       19:   73:	free(p->products);
       19:   74:	p->products = pointer;
       19:   75:	productEqualConstructor(&p->products[n], t);
       19:   75-block  0
call    0 returned 19
       19:   76:	return n;
        -:   77:}
        -:   78:
        -:   79:// removes the product with identification from repository
        -:   80:// in:
        -:   81:// p = repository where to remove from
        -:   82:// identification = product identification
        -:   83:// out:
        -:   84:// repository = repository - product
function repositorySterge called 7 returned 100% blocks executed 100%
        7:   85:bool repositorySterge(Products* p, unsigned int identification)
        -:   86:{
        7:   87:	Product *t = &(p->products[identification]);
        7:   88:	bool r = productGetMemory(t);
        7:   88-block  0
call    0 returned 7
        7:   89:	productSetMemory(t, 0);
call    0 returned 7
        7:   90:	return r;
        -:   91:}
        -:   92:
        -:   93:// sets the attributes for product with
        -:   94:// identification from repository
        -:   95:// in:
        -:   96:// p = repository
        -:   97:// i = product identification to set attributes
        -:   98:// t = product with new attributes to copy to product with
        -:   99:// i identification
        -:  100:// out:
        -:  101:// the product with i identification has new attributes
function repositorySetProduct called 2 returned 100% blocks executed 100%
        2:  102:void repositorySetProduct(Products* p, unsigned int i, Product* t)
        -:  103:{
        2:  104:	Product *j = &(p->products[i]);
        -:  105:	
        2:  106:	productEqualConstructor(j, t);
        2:  106-block  0
call    0 returned 2
        2:  107:}
        -:  108:
        -:  109:// returns pointer to product with identification
        -:  110:// in:
        -:  111:// p = repository where to search
        -:  112:// i = identification
        -:  113:// out:
        -:  114:// true
function repositoryGetProduct called 26 returned 100% blocks executed 100%
       26:  115:Product* repositoryGetProduct(Products* p, unsigned int i)
        -:  116:{
       26:  117:	return &p->products[i];
       26:  117-block  0
        -:  118:}
