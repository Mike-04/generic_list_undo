        -:    0:Source:/mnt/c/Users/White Fox/Downloads/l4/l4/service.c
        -:    0:Graph:/mnt/c/Users/White Fox/Downloads/l4/l4/cmake-build-debug-coverage/CMakeFiles/l4.dir/service.c.gcno
        -:    0:Data:/mnt/c/Users/White Fox/Downloads/l4/l4/cmake-build-debug-coverage/CMakeFiles/l4.dir/service.c.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2:
        -:    3:Solution written by
        -:    4:Ilovan Cristian Daniel
        -:    5:
        -:    6:*/
        -:    7:
        -:    8:#include "service.h"
        -:    9:
        -:   10:// adds new product with attributs
        -:   11:// in:
        -:   12:// p = repository
        -:   13:// type = char pointer to CHARSIZE array for product type
        -:   14:// producedBy = char pointer to CHARSIZE array for product proudcedBy
        -:   15:// model = char pointer to CHARSIZE array for product model
        -:   16:// price = unsigned int value for product price
        -:   17:// out:
        -:   18:// if the validation functions return true
        -:   19:// the repository p will have a new product
        -:   20:// with the attributes or the quantity of
        -:   21:// existing product with the same attribute will increase
        -:   22:// and the function returns true
        -:   23:// if the validation functions return false
        -:   24:// the repository does not change and the function
        -:   25:// returns false
function serviceAdauga called 10 returned 100% blocks executed 100%
       10:   26:bool serviceAdauga(Products* p, char* type, char* producedBy, char* model, int price)
        -:   27:{	
       10:   28:	if (!validPrice(price))
       10:   28-block  0
call    0 returned 10
branch  1 taken 1 (fallthrough)
branch  2 taken 9
        1:   29:		return 0;
        1:   29-block  0
        -:   30:	
        -:   31:	Product t, *j;
        -:   32:	
        9:   33:	productConstructor(&t, 0, type, producedBy, model, price, 1, 1);
        9:   33-block  0
call    0 returned 9
        -:   34:	
        9:   35:	int i = repositoryExistsAttributes(p, &t);
call    0 returned 9
        -:   36:	
        9:   37:	if (i != -1)
branch  0 taken 2 (fallthrough)
branch  1 taken 7
        -:   38:	{
        2:   39:		j = repositoryGetProduct(p, i);
        2:   39-block  0
call    0 returned 2
        2:   40:		productSetQuantity(j, productGetQuantity(j) + 1);
call    0 returned 2
call    1 returned 2
        2:   41:		return 1;
        -:   42:	}
        -:   43:	
        -:   44:	// repository part to add the product
        -:   45:	// the service does not know how the
        -:   46:	// repository stores the products
        -:   47:	// therefore the repository adds new products
        7:   48:	i = repositoryAdauga(p, &t);
        7:   48-block  0
call    0 returned 7
        7:   49:	productSetI(&p->products[i], i);
call    0 returned 7
        7:   50:	return 1;
        -:   51:}
        -:   52:
        -:   53:// updates existing product
        -:   54:// in:
        -:   55:// p = repository where to update
        -:   56:// i = unsigned int identification
        -:   57:// n = value to update
        -:   58:// j = what to update
        -:   59:// out:
        -:   60:// the product with identification from repository
        -:   61:// will be updated if the validation functions return true
        -:   62:// and the function returns true
        -:   63:// if the validation functions return false
        -:   64:// the function returns false
function serviceActualizare called 3 returned 100% blocks executed 100%
        3:   65:bool serviceActualizare(Products* p, unsigned int i, unsigned int n, unsigned int j)
        -:   66:{
        3:   67:	if (!repositoryExists(p, i))
        3:   67-block  0
call    0 returned 3
branch  1 taken 1 (fallthrough)
branch  2 taken 2
        1:   68:		return 0;
        1:   68-block  0
        -:   69:	
        2:   70:	Product *t = repositoryGetProduct(p, i);
        2:   70-block  0
call    0 returned 2
        -:   71:	
        2:   72:	if (j == 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   73:		productSetPrice(t, n);
        1:   73-block  0
call    0 returned 1
        -:   74:	
        2:   75:	if (j == 1)
        2:   75-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   76:		productSetQuantity(t, n);
        1:   76-block  0
call    0 returned 1
        -:   77:	
        2:   78:	return 1;
        2:   78-block  0
        -:   79:}
        -:   80:
        -:   81:// removes product from repository
        -:   82:// in:
        -:   83:// p = repository
        -:   84:// identification = product identification to remove
        -:   85:// out:
        -:   86:// the product from repository is removed
        -:   87:// only by setting attribute memory of the product = 0
        -:   88:// the function returns valid function value
function serviceSterge called 1 returned 100% blocks executed 100%
        1:   89:bool serviceSterge(Products* p, unsigned int identification)
        -:   90:{
        1:   91:	return repositorySterge(p, identification);
        1:   91-block  0
call    0 returned 1
        -:   92:}
        -:   93:
function compInt called 8 returned 100% blocks executed 100%
        8:   94:bool compInt(unsigned int a, unsigned int b)
        -:   95:{
        8:   96:	return a < b;
        8:   96-block  0
        -:   97:}
        -:   98:
        -:   99:// sorts products
        -:  100:// in:
        -:  101:// p = repository
        -:  102:// a = sort attribute
        -:  103:// c = sort order
        -:  104:// out:
        -:  105:// p is sorted
function serviceSort called 8 returned 100% blocks executed 100%
        8:  106:void serviceSort(Products* p, unsigned int a, unsigned int c,
        -:  107:	bool (*comp)(unsigned int, unsigned int))
        -:  108:{
        8:  109:	unsigned int size = p->size, qi, qj;
        -:  110:	Product t;
        -:  111:	
        8:  112:	if (c == 1)
        8:  112-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 4
        -:  113:	{
        4:  114:		if (a == 1)
        4:  114-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        -:  115:		{
        6:  116:			for (unsigned int i = 0; i < size; ++i)
        2:  116-block  0
        4:  116-block  1
        6:  116-block  2
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        6:  117:				for (unsigned int j = i + 1; j < size; ++j)
        4:  117-block  0
        2:  117-block  1
        6:  117-block  2
branch  0 taken 2
branch  1 taken 4 (fallthrough)
        -:  118:				{
        2:  119:					qi = productGetPrice(&p->products[i]);
        2:  119-block  0
call    0 returned 2
        2:  120:					qj = productGetPrice(&p->products[j]);
call    0 returned 2
        2:  121:					if (comp(qj,qi))
call    0 returned 2
branch  1 taken 1 (fallthrough)
branch  2 taken 1
        -:  122:					{
        1:  123:						productEqualConstructor(&t, &p->products[j]);
        1:  123-block  0
call    0 returned 1
        1:  124:						productEqualConstructor(&p->products[j], &p->products[i]);
call    0 returned 1
        1:  125:						productEqualConstructor(&p->products[i], &t);
call    0 returned 1
        -:  126:					}
        -:  127:				}
        -:  128:		}
        -:  129:		
        4:  130:		if (a == 2)
        4:  130-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        -:  131:		{
        6:  132:			for (unsigned int i = 0; i < size; ++i)
        2:  132-block  0
        4:  132-block  1
        6:  132-block  2
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        6:  133:				for (unsigned int j = i + 1; j < size; ++j)
        4:  133-block  0
        2:  133-block  1
        6:  133-block  2
branch  0 taken 2
branch  1 taken 4 (fallthrough)
        -:  134:				{
        2:  135:					qi = productGetQuantity(&p->products[i]);
        2:  135-block  0
call    0 returned 2
        2:  136:					qj = productGetQuantity(&p->products[j]);
call    0 returned 2
        2:  137:					if (comp(qj,qi))
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        -:  138:					{
        2:  139:						productEqualConstructor(&t, &p->products[j]);
        2:  139-block  0
call    0 returned 2
        2:  140:						productEqualConstructor(&p->products[j], &p->products[i]);
call    0 returned 2
        2:  141:						productEqualConstructor(&p->products[i], &t);
call    0 returned 2
        -:  142:					}
        -:  143:				}
        -:  144:		}
        -:  145:	}
        -:  146:	
        8:  147:	if (c == 2)
        8:  147-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 4
        -:  148:	{
        4:  149:		if (a == 1)
        4:  149-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        -:  150:		{
        6:  151:			for (unsigned int i = 0; i < size; ++i)
        2:  151-block  0
        4:  151-block  1
        6:  151-block  2
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        6:  152:				for (unsigned int j = i + 1; j < size; ++j)
        4:  152-block  0
        2:  152-block  1
        6:  152-block  2
branch  0 taken 2
branch  1 taken 4 (fallthrough)
        -:  153:				{
        2:  154:					qi = productGetPrice(&p->products[i]);
        2:  154-block  0
call    0 returned 2
        2:  155:					qj = productGetPrice(&p->products[j]);
call    0 returned 2
        2:  156:					if (comp(qi,qj))
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        -:  157:					{
        2:  158:						productEqualConstructor(&t, &p->products[j]);
        2:  158-block  0
call    0 returned 2
        2:  159:						productEqualConstructor(&p->products[j], &p->products[i]);
call    0 returned 2
        2:  160:						productEqualConstructor(&p->products[i], &t);
call    0 returned 2
        -:  161:					}
        -:  162:				}
        -:  163:		}
        -:  164:		
        4:  165:		if (a == 2)
        4:  165-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        -:  166:		{
        6:  167:			for (unsigned int i = 0; i < size; ++i)
        2:  167-block  0
        4:  167-block  1
        6:  167-block  2
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        6:  168:				for (unsigned int j = i + 1; j < size; ++j)
        4:  168-block  0
        2:  168-block  1
        6:  168-block  2
branch  0 taken 2
branch  1 taken 4 (fallthrough)
        -:  169:				{
        2:  170:					qi = productGetQuantity(&p->products[i]);
        2:  170-block  0
call    0 returned 2
        2:  171:					qj = productGetQuantity(&p->products[j]);
call    0 returned 2
        2:  172:					if (comp(qi,qj))
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        -:  173:					{
        2:  174:						productEqualConstructor(&t, &p->products[j]);
        2:  174-block  0
call    0 returned 2
        2:  175:						productEqualConstructor(&p->products[j], &p->products[i]);
call    0 returned 2
        2:  176:						productEqualConstructor(&p->products[i], &t);
call    0 returned 2
        -:  177:					}
        -:  178:				}
        -:  179:		}
        -:  180:	}
        8:  181:}
        -:  182:
        -:  183:// saves the filters in s for a filter action
        -:  184:// in:
        -:  185:// i = filter action
        -:  186:// s = array of size >= 7
        -:  187:// out:
        -:  188:// s = filters
function serviceFilter called 4 returned 100% blocks executed 100%
        4:  189:void serviceFilter(bool *s, unsigned int i)
        -:  190:{
       32:  191:	for (unsigned int i = 0; i < 7; ++i)
        4:  191-block  0
       32:  191-block  1
branch  0 taken 28
branch  1 taken 4 (fallthrough)
       28:  192:		s[i] = 0;
       28:  192-block  0
        -:  193:	
        4:  194:	if (i == 1)
        4:  194-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  195:		s[2] = 1;
        1:  195-block  0
        -:  196:	
        4:  197:	if (i == 2)
        4:  197-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  198:		s[4] = 1;
        1:  198-block  0
        -:  199:	
        4:  200:	if (i == 3)
        4:  200-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  201:		s[5] = 1;
        1:  201-block  0
        4:  202:}
